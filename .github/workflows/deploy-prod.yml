name: Deploy to Production

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      version:
        description: 'Version tag (e.g., v0.4.0-alpha, v1.0.0). Leave empty for auto-increment.'
        required: false
        default: ''

jobs:
  # Run tests first - reuse existing CI workflow
  test:
    uses: ./.github/workflows/ci.yml

  # Determine version to deploy
  get-version:
    runs-on: ubuntu-latest
    needs: [test]  # Only run if tests pass

    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for version calculation

    - name: Determine version
      id: version
      run: |
        if [ -n "${{ github.event.inputs.version }}" ]; then
          # Use manually specified version
          VERSION="${{ github.event.inputs.version }}"
          echo "Using manual version: $VERSION"
        else
          # Auto-increment: Get latest tag, increment minor version, add -alpha
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            # No tags yet, start with v0.1.0-alpha
            VERSION="v0.1.0-alpha"
            echo "No existing tags, starting with: $VERSION"
          else
            echo "Latest tag: $LATEST_TAG"

            # Extract version parts (handles both v0.1.0-alpha and v1.0.0 formats)
            # Remove 'v' prefix and any suffix after version numbers
            VERSION_NUM=$(echo "$LATEST_TAG" | sed 's/^v//' | sed 's/-.*$//')

            # Split into major.minor.patch
            MAJOR=$(echo "$VERSION_NUM" | cut -d. -f1)
            MINOR=$(echo "$VERSION_NUM" | cut -d. -f2)
            PATCH=$(echo "$VERSION_NUM" | cut -d. -f3)

            # Increment minor version
            MINOR=$((MINOR + 1))

            # Preserve suffix if it was -alpha or -beta, default to -alpha
            if [[ "$LATEST_TAG" == *"-beta"* ]]; then
              SUFFIX="-beta"
            elif [[ "$LATEST_TAG" == *"-alpha"* ]]; then
              SUFFIX="-alpha"
            else
              # If no suffix (e.g., v1.0.0), keep incrementing without suffix
              SUFFIX=""
            fi

            VERSION="v${MAJOR}.${MINOR}.${PATCH}${SUFFIX}"
            echo "Auto-incremented to: $VERSION"
          fi
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Deploying version: $VERSION"

  build-and-push:
    runs-on: ubuntu-latest
    needs: [test, get-version]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate to Google Cloud
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: gcloud auth configure-docker

    # Build the Docker image
    - name: Build Docker image
      run: |
        docker build -t music-graph:latest .

    # Tag with version, git SHA, and 'production'
    - name: Tag image
      run: |
        IMAGE_NAME="gcr.io/${{ secrets.GCP_PROJECT_ID }}/music-graph"
        VERSION="${{ needs.get-version.outputs.version }}"
        GIT_SHA="${{ github.sha }}"

        # Tag with version
        docker tag music-graph:latest ${IMAGE_NAME}:${VERSION}
        # Tag with SHA for traceability
        docker tag music-graph:latest ${IMAGE_NAME}:${GIT_SHA}
        # Tag with 'production' for easy reference
        docker tag music-graph:latest ${IMAGE_NAME}:production
        # Tag with 'latest'
        docker tag music-graph:latest ${IMAGE_NAME}:latest

    # Push to GCR
    - name: Push to GCR
      run: |
        IMAGE_NAME="gcr.io/${{ secrets.GCP_PROJECT_ID }}/music-graph"
        VERSION="${{ needs.get-version.outputs.version }}"

        docker push ${IMAGE_NAME}:${VERSION}
        docker push ${IMAGE_NAME}:${{ github.sha }}
        docker push ${IMAGE_NAME}:production
        docker push ${IMAGE_NAME}:latest

        echo "‚úÖ Images pushed to GCR:"
        echo "  - ${IMAGE_NAME}:${VERSION}"
        echo "  - ${IMAGE_NAME}:production"
        echo "  - ${IMAGE_NAME}:latest"

  deploy-to-prod:
    runs-on: ubuntu-latest
    needs: [build-and-push, get-version]

    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Deploy to Cloud Run
      run: |
        VERSION="${{ needs.get-version.outputs.version }}"

        gcloud run deploy music-graph-prod \
          --image gcr.io/${{ secrets.GCP_PROJECT_ID }}/music-graph:${VERSION} \
          --region us-east1 \
          --quiet

        echo "=== Deployment Complete ==="
        echo "Deployed version: ${VERSION}"
        echo "Deployed commit: ${{ github.sha }}"
        echo "Deployed by: ${{ github.actor }}"

    - name: Health check
      run: |
        echo "=== Running health check ==="
        # Wait for deployment to stabilize
        sleep 10

        # Check if site is responding
        if curl -f -s -o /dev/null https://music-graph.billgrant.io/; then
          echo "‚úÖ Production site is responding"
        else
          echo "‚ùå Production site health check failed"
          exit 1
        fi

  create-release:
    runs-on: ubuntu-latest
    needs: [deploy-to-prod, get-version]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create GitHub Release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        ACTOR: ${{ github.actor }}
        COMMIT: ${{ github.sha }}
        PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      run: |
        VERSION="${{ needs.get-version.outputs.version }}"

        # Create git tag
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "$VERSION" -m "Release $VERSION"
        git push origin "$VERSION"

        # Create GitHub release with multi-line notes
        RELEASE_NOTES=$(cat <<EOF
        Deployed to production on $(date +'%Y-%m-%d %H:%M:%S UTC')

        **Deployed by:** ${ACTOR}
        **Commit:** ${COMMIT}
        **Docker image:** gcr.io/${PROJECT_ID}/music-graph:${VERSION}

        ## Deployment
        - ‚úÖ Tests passed
        - ‚úÖ Image built and pushed to GCR
        - ‚úÖ Database backup created
        - ‚úÖ Deployed to production
        - ‚úÖ Health checks passed

        ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
        EOF
        )

        gh release create "$VERSION" \
          --title "Release $VERSION" \
          --notes "$RELEASE_NOTES" \
          --latest

    - name: Deployment summary
      run: |
        echo "üéâ Production deployment complete!"
        echo ""
        echo "Version: ${{ needs.get-version.outputs.version }}"
        echo "Commit: ${{ github.sha }}"
        echo "Deployed by: ${{ github.actor }}"
        echo "Release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.get-version.outputs.version }}"
